from had.shourtcuts import render, redirect, error_render, RenderSettings
from project import settings
from project.shourtcuts import redirect_for_slug, reverse_for_slug
import random
from project.tree import Tree, gen_tree_htmls  # , gen_pages_ordered_by_tree
import traceback
from .forms import PageForm
import datetime
from zoneinfo import ZoneInfo
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

table_name = "table-wiki-stg"
storage_table_name = "table-wiki-storage-stg"

def index(request):
  import boto3
  from boto3.dynamodb.conditions import Key
  if request.auth:
    if request.username == "admin":
      usernames = ["admin"]
    else:
      usernames = ["admin", request.username]
  else:
    usernames = ["admin"]
  pages = []
  for username in usernames:
    table = boto3.resource('dynamodb').Table(table_name)
    response = table.query(
      KeyConditionExpression=Key('username').eq(username)
    )
    if response['Count'] == 0:
      continue
    else:
      pages.extend(response['Items'])
  pages = [page for page in pages if "last_updated" in page.keys()]
  pages = sorted(pages, key=lambda x: x['last_updated'], reverse=True)
  RenderSettings.env.filters["url_for_slug"] = reverse_for_slug
  if len(pages) > 10:
    pages = pages[:10]
  context = {
    "tree_htmls": gen_tree_htmls(request, table_name, a_white=False),
    "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
    "pages": pages
  }
  return render(request, 'wiki/index.html', context)

def _share_code_checker(share_code, table, username=None, slug=None):
  from boto3.dynamodb.conditions import Key
  response = table.query(
    IndexName="ShareCodeIndex",
    KeyConditionExpression=Key('share_code').eq(share_code)
  )
  if response["Count"] > 0:
    if username is not None and slug is not None and response["Count"] == 1:
      if response["Items"][0]["username"] == username and response["Items"][0]["slug"] == slug:
        return True
      else:
        return False
  else:
    return True

def create(request):
  import boto3
  from botocore.exceptions import ClientError
  if request.method == "POST":
    action = request.body["action"]
    form = PageForm(**request.body)
    Item = form.data
    Item["username"] = request.username
    Item["last_updated"] = datetime.datetime.now(ZoneInfo("Asia/Tokyo")).strftime("%Y-%m-%d %H:%M:%S")
    table = boto3.resource('dynamodb').Table(table_name)
    if not _share_code_checker(Item["share_code"], table):
      form = PageForm(data=Item)
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "share_edit": False,
        "type": "create",
        "share_code": Item["share_code"],
        "author": True, 
        "form": form,
        "error_message": "Share code already exists."
      }
      return render(request, 'wiki/edit.html', context)
    try:
      response = table.put_item(
        Item=Item,
        ConditionExpression="attribute_not_exists(username) AND attribute_not_exists(slug)"
      )
      _set_publics(Item["text"], request.username, Item["public"] or Item["share"])
      if action == "end":
        return redirect_for_slug("wiki:detail", Item["username"], Item["slug"])
      elif action == "continue":
        return redirect_for_slug("wiki:edit", Item["username"], Item["slug"])
      else:
        return error_render(request, "Invalid action.")
    except ClientError as e:
      if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
        error_message = "Item with the same partition key and sort key already exists."
      else:
        import traceback
        error_message = traceback.format_exc()
      form = PageForm(data=Item)
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "share_edit": False,
        "type": "create",
        "share_code": Item["share_code"],
        "author": True, 
        "form": form,
        "error_message": error_message
      }
      return render(request, 'wiki/edit.html', context)
  else:
    allow="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    length=32
    share_code = ''.join(random.choice(allow) for i in range(length))
    initial = {
      "share_code": share_code,
      "priority": 0,
    }
    form = PageForm(data=initial)
    context = {
      "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
      "share_edit": False,
      "type": "create",
      "share_code": share_code,
      "author": True, 
      "form": form,
      "error_message": None
    }
    return render(request, 'wiki/edit.html', context)

def edit(request, username, **kwargs):
  import boto3
  from botocore.exceptions import ClientError
  from boto3.dynamodb.conditions import Key
  slug_list = []
  if len(kwargs) == 0:
    return error_render(request, "Slug is empty.")
  for i in range(1,6):
    if f"slug{i}" in kwargs:
      slug_list.append(kwargs[f"slug{i}"])
    else:
      break
  slug = "/".join(slug_list)
  table = boto3.resource('dynamodb').Table(table_name)
  if request.method == "POST":
    # 権限を確認
    if username != request.username:
      response = table.get_item(
        Key={
          'username': username,
          'slug': slug
        }
      )
      if "Item" not in response:
        context = {
          "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
          "message": "Page not found."
        }
        return render(request, 'wiki/not_found.html', context=context)
      if not response["Item"]["public"] or not response["Item"]["edit_permission"]:
        context = {
          "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
          "message": "Page not found."
        }
        return render(request, 'wiki/not_found.html', context=context)
    # 処理
    action = request.body["action"]
    form = PageForm(**request.body)
    Item = form.data
    Item["username"] = username
    Item["last_updated"] = datetime.datetime.now(ZoneInfo("Asia/Tokyo")).strftime("%Y-%m-%d %H:%M:%S")
    if _share_code_checker(Item["share_code"], table, username=username, slug=slug):
      if slug == Item["slug"]:
        table.update_item(
          Key={
            'username': username,
            'slug': Item["slug"]
          },
          UpdateExpression="set #title=:ti, #text=:te, #share=:sh, #public=:pu, #share_code=:sc, #priority=:pr, #last_updated=:lu, #edit_permission=:ep, #share_edit_permission=:sep",
          ExpressionAttributeNames={
            "#title": "title",
            "#text": "text",
            "#share": "share",
            "#public": "public",
            "#share_code": "share_code",
            "#priority": "priority",
            "#edit_permission": "edit_permission",
            "#share_edit_permission": "share_edit_permission",
            "#last_updated": "last_updated"
          },
          ExpressionAttributeValues={
            ':ti': Item["title"],
            ':te': Item["text"],
            ':sh': Item["share"],
            ':pu': Item["public"],
            ':sc': Item["share_code"],
            ':pr': Item["priority"],
            ':ep': Item["edit_permission"],
            ':sep': Item["share_edit_permission"],
            ':lu': datetime.datetime.now(ZoneInfo("Asia/Tokyo")).strftime("%Y-%m-%d %H:%M:%S")
          }
        )
        if username == request.username:
          _set_publics(Item["text"], username, Item["public"] or Item["share"])
        if action == "end":
          return redirect_for_slug("wiki:detail", username, Item["slug"])
        elif action == "continue":
          return redirect_for_slug("wiki:edit", username, Item["slug"])
        else:
          return error_render(request, "Invalid action.")
      else:
        try:
          response = table.put_item(
            Item=Item,
            ConditionExpression="attribute_not_exists(username) AND attribute_not_exists(slug)"
          )
          if username == request.username:
            _set_publics(Item["text"], username, Item["public"] or Item["share"])
          table.delete_item(
            Key={
              'username': username,
              'slug': slug
            }
          )
          return redirect_for_slug("wiki:detail", username, Item["slug"])
        except ClientError as e:
          if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
            error_message = "Item with the same partition key and sort key already exists."
          else:
            import traceback
            error_message = traceback.format_exc()
          form = PageForm(data=Item)
          context = {
            "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
            "share_edit": False,
            "type": "edit",
            "share_code": Item["share_code"],
            "author": True, 
            "form": form,
            "error_message": error_message
          }
          return render(request, 'wiki/edit.html', context)
    else:
      form = PageForm(data=Item)
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "share_edit": False,
        "type": "create",
        "share_code": Item["share_code"],
        "author": True, 
        "form": form,
        "error_message": "Share code already exists."
      }
      return render(request, 'wiki/edit.html', context)
  else:
    response = table.get_item(
      Key={
        'username': username,
        'slug': slug
        }
    )
    if "Item" not in response:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Page not found."
      }
      return render(request, 'wiki/not_found.html', context=context)
    else:
      return _render_edit_get(request, response["Item"], from_share_code=False)

def _render_edit_get(request, item, from_share_code=False, error_message=None):
  # 権限を確認
  if from_share_code:
    if not item["share"] or not item["share_edit_permission"]:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Invalid Code."
      }
      return render(request, 'wiki/not_found.html', context=context)
  else:
    if item["username"] != request.username:
      if not item["public"] or not item["edit_permission"]:
        context = {
          "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
          "message": "Page not found."
        }
        return render(request, 'wiki/not_found.html', context=context)
  RenderSettings.env.filters["url_for_slug"] = reverse_for_slug
  form = PageForm(data=item)
  if from_share_code:
    _type = "share_edit"
  else:
    _type = "edit"
  context = {
    "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
    "type": _type,
    "item": item,
    "form": form,
    "error_message": error_message
  }
  return render(request, 'wiki/edit.html', context)

def share_edit(request, share_code):
  import boto3
  from boto3.dynamodb.conditions import Key
  table = boto3.resource('dynamodb').Table(table_name)
  if request.method == "POST":
    # usernameとslugを取得
    response = table.query(
      IndexName="ShareCodeIndex",
      KeyConditionExpression=Key('share_code').eq(share_code)
    )
    if response["Count"] == 0:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Page not found."
      }
      return render(request, 'wiki/not_found.html', context=context)
    elif response["Count"] > 1:
      return error_render(request, "Duplicate page.")
    # 権限の確認
    if not response["Items"][0]["share"] or not response["Items"][0]["share_edit_permission"]:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Invalid Code."
      }
      return render(request, 'wiki/not_found.html', context=context)
    username = response["Items"][0]["username"]
    slug = response["Items"][0]["slug"]
    action = request.body["action"]
    form = PageForm(**request.body)
    Item = form.data
    Item["last_updated"] = datetime.datetime.now(ZoneInfo("Asia/Tokyo")).strftime("%Y-%m-%d %H:%M:%S")
    table.update_item(
      Key={
        'username': username,
        'slug': slug
      },
      UpdateExpression="set #title=:ti, #text=:te, #last_updated=:lu",
      ExpressionAttributeNames={
        "#title": "title",
        "#text": "text",
        "#last_updated": "last_updated"
      },
      ExpressionAttributeValues={
        ':ti': Item["title"],
        ':te': Item["text"],
        ':lu': datetime.datetime.now(ZoneInfo("Asia/Tokyo")).strftime("%Y-%m-%d %H:%M:%S")
      }
    )
    if action == "end":
      return redirect("wiki:share_detail", share_code=share_code)
    elif action == "continue":
      return redirect("wiki:share_edit", share_code=share_code)
    else:
      return error_render(request, "Invalid action.")
  else:
    response = table.query(
      IndexName="ShareCodeIndex",
      KeyConditionExpression=Key('share_code').eq(share_code)
    )
    if response["Count"] == 0:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Page not found."
      }
      return render(request, 'wiki/not_found.html', context=context)
    elif response["Count"] > 1:
      return error_render(request, "Duplicate page.")
    else:
      return _render_edit_get(request, response["Items"][0], from_share_code=True)

def detail(request, username, **kwargs):
  import boto3
  from boto3.dynamodb.conditions import Key
  slug_list = []
  if len(kwargs) == 0:
    return error_render(request, "Slug is empty.")
  for i in range(1,6):
    if f"slug{i}" in kwargs:
      slug_list.append(kwargs[f"slug{i}"])
    else:
      break
  slug = "/".join(slug_list)
  table = boto3.resource('dynamodb').Table(table_name)
  response = table.get_item(
    Key={
      'username': username,
      'slug': slug
      }
  )
  if "Item" not in response:
    context = {
      "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
      "message": "Page not found."
    }
    return render(request, 'wiki/not_found.html', context=context)
  else:
    return _render_detail(request, response["Item"], from_share_code=False)

def share_detail(request, share_code):
  import boto3
  from boto3.dynamodb.conditions import Key
  table = boto3.resource('dynamodb').Table(table_name)
  response = table.query(
    IndexName="ShareCodeIndex",
    KeyConditionExpression=Key('share_code').eq(share_code)
  )
  if response["Count"] == 0:
    context = {
      "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
      "message": "Page not found."
    }
    return render(request, 'wiki/not_found.html', context=context)
  elif response["Count"] > 1:
    return error_render(request, "Duplicate page.")
  else:
    return _render_detail(request, response["Items"][0], from_share_code=True)

def _render_detail(request, item, from_share_code=False):
  RenderSettings.env.filters["url_for_slug"] = reverse_for_slug
  if from_share_code:
    if not item["share"]:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Invalid Code."
      }
      return render(request, 'wiki/not_found.html', context=context)
  else:
    if item["username"] != request.username and not item["public"]:
      context = {
        "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
        "message": "Page not found."
      }
      return render(request, 'wiki/not_found.html', context=context)
  context = {
    "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
    "item": item,
    "from_share_code": from_share_code
  }
  return render(request, 'wiki/detail.html', context)

def delete(request, username, **kwargs):
  import boto3
  from boto3.dynamodb.conditions import Key
  RenderSettings.env.filters["url_for_slug"] = reverse_for_slug
  if username != request.username:
    context = {
      "nav_tree_htmls": gen_tree_htmls(request, table_name, a_white=True),
      "message": "Page not found."
    }
    return render(request, 'wiki/not_found.html', context=context)
  slug_list = []
  if len(kwargs) == 0:
    return error_render(request, "Slug is empty.")
  for i in range(1,6):
    if f"slug{i}" in kwargs:
      slug_list.append(kwargs[f"slug{i}"])
    else:
      break
  slug = "/".join(slug_list)
  table = boto3.resource('dynamodb').Table(table_name)
  table.delete_item(
    Key={
      'username': username,
      'slug': slug
    }
  )
  return redirect("wiki:index")

def _set_publics(text, username, public):
  import boto3
  storage_table = boto3.resource('dynamodb').Table(storage_table_name)
  logger.info("set image public")
  logger.info(f"username: {username}")
  logger.info(f"public: {public}")
  for filename in _extract_image_file(text):
    logger.info(f"filename: {filename}")
    _set_public(filename, username, public, storage_table)

def _extract_image_file(text):
  import re
  pattern = r'!\[[^\]]*\]\(([^()]+\.[^()]+)\)'
  matches = re.findall(pattern, text)
  return [ i[13:] for i in matches if i[:13] == "/storage/get/" ]

def _set_public(filename, username, public, storage_table):
  from boto3.dynamodb.conditions import Key
  response = storage_table.get_item(
    Key={
      "filename": filename
    }
  )
  try:
    if username == response["Item"]["owner"] and response["Item"]["auto_permission"]:
      storage_table.update_item(
        Key={
          'filename': filename
        },
        UpdateExpression="set #public=:pu",
        ExpressionAttributeNames={
          "#public": "public"
        },
        ExpressionAttributeValues={
          ':pu': public
        }
      )
      return True
    else:
      return False
  except KeyError:
    return False

